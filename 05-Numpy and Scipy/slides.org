#+OPTIONS: reveal_center:t reveal_control:t reveal_height:-1
#+OPTIONS: reveal_history:nil reveal_keyboard:t reveal_mathjax:nil
#+OPTIONS: reveal_overview:t reveal_progress:t
#+OPTIONS: reveal_rolling_links:nil reveal_slide_number:t
#+OPTIONS: reveal_title_slide:t reveal_width:-1
#+options: toc:nil ^:nil num:nil
#+REVEAL_MARGIN: -1
#+REVEAL_MIN_SCALE: -1
#+REVEAL_MAX_SCALE: -1
#+REVEAL_ROOT: ../reveal.js
#+REVEAL_TRANS: default
#+REVEAL_SPEED: default
#+REVEAL_THEME: black
#+REVEAL_EXTRA_CSS: ../code_formatting.css
#+REVEAL_EXTRA_JS: 
#+REVEAL_HLEVEL: 1
#+REVEAL_TITLE_SLIDE_TEMPLATE: <h1>%t</h1> <h2>%a</h2> <h2>%e</h2> <h2>%d</h2>
#+REVEAL_TITLE_SLIDE_BACKGROUND:
#+REVEAL_TITLE_SLIDE_BACKGROUND_SIZE:
#+REVEAL_TITLE_SLIDE_BACKGROUND_REPEAT:
#+REVEAL_TITLE_SLIDE_BACKGROUND_TRANSITION:
#+REVEAL_MATHJAX_URL: http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
#+REVEAL_SLIDE_NUMBER: t
#+REVEAL_PREAMBLE:
#+REVEAL_HEAD_PREAMBLE:
#+REVEAL_POSTAMBLE:
#+REVEAL_MULTIPLEX_ID:
#+REVEAL_MULTIPLEX_SECRET:
#+REVEAL_MULTIPLEX_URL:
#+REVEAL_MULTIPLEX_SOCKETIO_URL:
#+REVEAL_PLUGINS:

#+AUTHOR: Sebastian Hahn
#+EMAIL: 
#+TITLE: Numpy and Scipy Packages

* Numpy
- The [[http://www.numpy.org][numpy package]] is used in almost all numerical computation using Python
- It is a package that provide high-performance vector, matrix and
  higher-dimensional data structures
- It is implemented in C and Fortran so when calculations are vectorized
  (formulated with vectors and matrices), performance is very good

To use *numpy* you need to import the module:
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
import numpy as np 
print("Numpy version {:}".format(np.__version__))
#+end_src

#+results:
* Getting started
- [[http://www.scipy.org/scipylib/download.html][Getting Numpy]]
- [[http://docs.scipy.org/doc/][Numpy and scipy documentation page]]
- [[http://www.scipy.org/Tentative_NumPy_Tutorial][Numpy tutorial]]
- [[http://www.scipy.org/NumPy_for_Matlab_Users][Numpy for MATLAB Users]]
- [[http://www.scipy.org/Numpy_Functions_by_Category][Numpy functions by category]]
** Creating numpy arrays
There are a number of ways to initialize new numpy arrays, for example from
- a Python list or tuples
- using functions that are dedicated to generating numpy arrays, such as
  =np.arange=, =np.linspace=, etc.
- reading data from files
*** From lists
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# a vector: the argument to the function is a Python list
v = np.array([1, 2, 3, 4])
print(v)
#+end_src

#+RESULTS:
: 
: >>> [1 2 3 4]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# a matrix: the argument to the function is a nested Python list
M = np.array([[1, 2], [3, 4]])
print(M)
#+end_src

#+RESULTS:
: 
: >>> [[1 2]
:  [3 4]]

*** Difference between v and M

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(type(v), type(M))
#+end_src

#+RESULTS:
: (<type 'numpy.ndarray'>, <type 'numpy.ndarray'>)
- The difference between the v and M arrays is only their shapes.
- The information about the shape of an array by using the =ndarray.shape=
  property.

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(v.shape, M.shape)
#+end_src

#+RESULTS:
: ((4,), (2, 2))
** Numpy.ndarray
So far the =numpy.ndarray= looks awefully much like a Python list (or nested
list). Why not simply use Python lists for computations instead of a new array
type?

There are several reasons:
- Python lists are very general. Each element can be any kind of object. They
  are dynamically typed. They do not support mathematical functions such as
  matrix and dot multiplications, etc. Implementating such functions for Python
  lists would not be very efficient because of the dynamic typing
** 
- Numpy arrays are statically typed and homogeneous. The type of the elements is
  determined when the array is created.
- Numpy arrays are memory efficient and element access is fast.
- Because of the static typing, fast implementation of mathematical functions
  such as multiplication and addition of numpy arrays can be implemented in a
  compiled language (C and Fortran is used).
** Type of an array
Using the =ndarray.dtype= (data type) property, we can see the type of an array:

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(v.dtype, M.dtype)
#+end_src

We get an error if we try to assign a value of an uncastable type to an element
in a numpy array:

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
M[0, 0] = "hello"
#+end_src
