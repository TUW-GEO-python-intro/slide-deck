#+OPTIONS: reveal_center:t reveal_control:t reveal_height:-1
#+OPTIONS: reveal_history:nil reveal_keyboard:t reveal_mathjax:nil
#+OPTIONS: reveal_overview:t reveal_progress:t
#+OPTIONS: reveal_rolling_links:nil reveal_slide_number:t
#+OPTIONS: reveal_title_slide:t reveal_width:-1
#+options: toc:nil ^:nil num:nil
#+REVEAL_MARGIN: -1
#+REVEAL_MIN_SCALE: -1
#+REVEAL_MAX_SCALE: -1
#+REVEAL_ROOT: ../reveal.js
#+REVEAL_TRANS: default
#+REVEAL_SPEED: default
#+REVEAL_THEME: black
#+REVEAL_EXTRA_CSS: ../code_formatting.css
#+REVEAL_EXTRA_JS: 
#+REVEAL_HLEVEL: 1
#+REVEAL_TITLE_SLIDE_TEMPLATE: <h1>%t</h1> <h2>%a</h2> <h2>%e</h2> <h2>%d</h2>
#+REVEAL_TITLE_SLIDE_BACKGROUND:
#+REVEAL_TITLE_SLIDE_BACKGROUND_SIZE:
#+REVEAL_TITLE_SLIDE_BACKGROUND_REPEAT:
#+REVEAL_TITLE_SLIDE_BACKGROUND_TRANSITION:
#+REVEAL_MATHJAX_URL: http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
#+REVEAL_SLIDE_NUMBER: t
#+REVEAL_PREAMBLE:
#+REVEAL_HEAD_PREAMBLE:
#+REVEAL_POSTAMBLE:
#+REVEAL_MULTIPLEX_ID:
#+REVEAL_MULTIPLEX_SECRET:
#+REVEAL_MULTIPLEX_URL:
#+REVEAL_MULTIPLEX_SOCKETIO_URL:
#+REVEAL_PLUGINS:

#+AUTHOR: Sebastian Hahn
#+EMAIL: 
#+TITLE: Numpy and Scipy Packages

* Numpy
- The [[http://www.numpy.org][numpy package]] is used in almost all numerical computation using Python
- It is a package that provide high-performance vector, matrix and
  higher-dimensional data structures
- It is implemented in C and Fortran so when calculations are vectorized
  (formulated with vectors and matrices), performance is very good

To use numpy you need to import the module
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
import numpy as np 
print("Numpy version {:}".format(np.__version__))
#+end_src

#+results:
: 
: Numpy version 1.8.2
* Getting started
- [[http://www.scipy.org/scipylib/download.html][Getting Numpy]]
- [[http://docs.scipy.org/doc/][Numpy and scipy documentation page]]
- [[http://www.scipy.org/Tentative_NumPy_Tutorial][Numpy tutorial]]
- [[http://www.scipy.org/NumPy_for_Matlab_Users][Numpy for MATLAB Users]]
- [[http://www.scipy.org/Numpy_Functions_by_Category][Numpy functions by category]]
* Creating Numpy arrays
There are a number of ways to initialize new numpy arrays, for example from
- a Python list or tuples
- using functions that are dedicated to generating Numpy arrays, such as
  [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html][np.arange]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html][np.linspace]], etc.
- reading data from files
** From lists
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# a vector: the argument to the function is a Python list
v = np.array([1, 2, 3, 4])
print(v)
#+end_src

#+RESULTS:
: 
: >>> [1 2 3 4]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# a matrix: the argument to the function is a nested Python list
M = np.array([[1, 2], [3, 4]])
print(M)
#+end_src

#+RESULTS:
: 
: >>> [[1 2]
:  [3 4]]

*** Difference between v and M

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(type(v), type(M))
#+end_src

#+RESULTS:
: (<type 'numpy.ndarray'>, <type 'numpy.ndarray'>)
The difference between the v and M arrays is only their shapes. The information
about the shape of an array by using the =ndarray.shape= property.

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(v.shape, M.shape)
#+end_src

#+RESULTS:
: ((4,), (2, 2))
*** Numpy array vs. lists
So far the =numpy.ndarray= looks awefully much like a Python list (or nested
list). Why not simply use Python lists for computations instead of a new array
type?

There are several reasons:
- Python lists are very general. Each element can be any kind of object. They
  are dynamically typed. They do not support mathematical functions such as
  matrix and dot multiplications, etc. Implementating such functions for Python
  lists would not be very efficient because of the dynamic typing
*** 
- Numpy arrays are statically typed and homogeneous. The type of the elements is
  determined when the array is created.
- Numpy arrays are memory efficient and element access is fast.
- Because of the static typing, fast implementation of mathematical functions
  such as multiplication and addition of numpy arrays can be implemented in a
  compiled language (C and Fortran is used).
*** Type of an array
Using the =ndarray.dtype= (data type) property, we can see the type of an array:

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(v.dtype, M.dtype)
#+end_src

#+RESULTS:
: (dtype('int64'), dtype('int64'))

We get an error if we try to assign a value of an uncastable type to an element
in a Numpy array:

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
M[0, 0] = "hello"
#+end_src

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: ValueError: invalid literal for long() with base 10: 'hello'
*** 
But be aware that the type is defined by the array at the initialization and
won't be changed if a value from another type is assigned
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
M[0, 0] = 1.2345
print(M[0, 0], M.dtype)
#+end_src

#+RESULTS:
: 
: (1, dtype('int64'))

However, the data type can be changed later if it is desired (e.g. using =numpy.ndarray.astype=). 
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = M.astype(np.float32)
print(x, x.dtype)
#+end_src

#+RESULTS:
: 
: (array([[ 1.,  2.],
:        [ 3.,  4.]], dtype=float32), dtype('float32'))
*** 
If we want, we can explicitly define the data type of the array during creation,
using the =dtype= keyword argument.
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
M = np.array([[1, 2], [3, 4]], dtype=np.complex)
print(M)
#+end_src

#+RESULTS:
: 
: [[ 1.+0.j  2.+0.j]
:  [ 3.+0.j  4.+0.j]]

Common types that can be used with =dtype= are, e.g.: =np.int16=, =np.int32=,
=np.uint32=, =np.float64=, =np.complex=, =np.bool=, =np.object=, etc.
** Using array-generating functions
For larger arrays it is unpractical to initialize the data manually, using
explicit python lists. Instead we can use one of the many functions in Numpy
that generate arrays of different forms. Some of the more common ones are:

Ones and Zeros

[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.empty.html][np.empty]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html][np.zeros]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.ones.html][np.ones]]

Numerical ranges

[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html][np.arange]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html][np.linspace]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.logspace.html][np.logspace]]
** 
Random numbers

[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html][np.random.rand]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html][np.random.randn]]

Building matrices

[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.identity.html][np.identity]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html][np.diag]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.tri.html][np.tri]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.tril.html][np.tril]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.triu.htmln][p.triu]]

From existing data

[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfile.html][np.fromfile]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromstring.html][np.fromstring]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html][np.loadtxt]]
** Ones and Zeros
[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html][np.zeros]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.zeros(3, dtype=np.int)
print(x)
#+end_src

#+RESULTS:
: 
: [0 0 0]

[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.ones.html][np.ones]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.ones((3, 3), dtype=np.float)
print(x)
#+end_src

#+RESULTS:
: 
: [[ 1.  1.  1.]
:  [ 1.  1.  1.]
:  [ 1.  1.  1.]]
** Numerical ranges
[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html][np.arange]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# creates a range, arguments: [start=0], stop, [step=1]
x = np.arange(10) 
print(x)
#+end_src

#+RESULTS:
: 
: >>> [0 1 2 3 4 5 6 7 8 9]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.arange(2, -1, -0.5)
print(x)
#+end_src

#+RESULTS:
: 
: [ 2.   1.5  1.   0.5  0.  -0.5]
** 
[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html][np.linspace]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# using linspace, both end points ARE included
x = np.linspace(0, 10, 11)
print(x)
#+end_src

#+RESULTS:
: 
: >>> [  0.   1.   2.   3.   4.   5.   6.   7.   8.   9.  10.]

[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.logspace.html][np.logspace]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.logspace(0, 10, 11, base=10)
print(x)
#+end_src

#+RESULTS:
: 
: [  1.00000000e+00   1.00000000e+01   1.00000000e+02   1.00000000e+03
:    1.00000000e+04   1.00000000e+05   1.00000000e+06   1.00000000e+07
:    1.00000000e+08   1.00000000e+09   1.00000000e+10]
** Random numbers
[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html][np.random.rand]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# each element is from the uniform random distribution [0,1]
x = np.random.rand(5, 5) 
print(x)
#+end_src

#+RESULTS:
: 
: >>> [[ 0.12897155  0.87782618  0.47143453  0.34784699  0.13578377]
:  [ 0.93973483  0.86432752  0.79413251  0.27473308  0.78749779]
:  [ 0.05024311  0.78804844  0.15038138  0.31076899  0.01102947]
:  [ 0.78277288  0.31500672  0.32906197  0.92859071  0.70598166]
:  [ 0.19505452  0.52904327  0.93459818  0.14782289  0.0733796 ]]

The standard normal distribution is available as [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.randn.html][np.random.randn]]
** Building matrices
[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html][np.diag]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.diag([1, 2, 3]) # the diagonal of an otherwise zero matrix
print(x)
#+end_src

#+RESULTS:
: 
: [[1 0 0]
:  [0 2 0]
:  [0 0 3]]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
y = np.diag(x)
print(y)
#+end_src

#+RESULTS:
: 
: [1 2 3]
** 
[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.tri.html][np.tri]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# ones at and below the given diagonal and zeros elsewhere
x = np.tri(3) 
print(x)
#+end_src

#+RESULTS:
: 
: >>> [[ 1.  0.  0.]
:  [ 1.  1.  0.]
:  [ 1.  1.  1.]]

[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.triu.html][np.triu]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# Upper triangle of an array.
x = np.triu(np.ones((3, 3))*2)
print(x)
#+end_src

#+RESULTS:
: 
: >>> [[ 2.  2.  2.]
:  [ 0.  2.  2.]
:  [ 0.  0.  2.]]
** More properties of the numpy arrays
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
M = np.ones((3, 3), dtype=np.uint8) * 21
print(M.dtype)
M.itemsize # bytes per element
#+end_src

#+RESULTS:
: 
: uint8
: 1

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
M.nbytes # number of bytes
#+end_src

#+RESULTS:
: 9

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
M.ndim # number of dimensions
#+end_src

#+RESULTS:
: 2
* Manipulating arrays
- Basic indexing and slicing
- Advanced indexing
  - Index arrays
  - Boolean index arrays
** Basic indexing
Array indexing refers to any use of the square brackets =[]= to index array
values. There are many options to indexing, which give Numpy indexing great
power, but with power comes some complexity and the potential for confusion.

We can index elements in an array using the square bracket and indices:
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# v is a vector, and has only one dimension, taking one index
v = np.arange(10)
print(v[0], v[-2])
#+end_src

#+RESULTS:
: 
: >>> (0, 8)
** Basic indexing
Unlike lists and tuples, Numpy arrays support multidimensional indexing for
multidimensional arrays. That means that it is not necessary to separate each
dimensionâ€™s index into its own set of square brackets.

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
v.shape = (2, 5)
print(v)
# v is now a 2 dimensional array, taking two indices 
print(v[1, 1]) # same as v[1][1]
#+end_src

#+RESULTS:
: 
: [[0 1 2 3 4]
:  [5 6 7 8 9]]
: ... 6
** Basic indexing
Note that if one indexes a multidimensional array with fewer indices than
dimensions, one gets a subdimensional array. For example:

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(v[0])
#+end_src

#+RESULTS:
: [0 1 2 3 4]

The same thing can be achieved with using =:= 

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(v[0, :])
#+end_src

#+RESULTS:
: [0 1 2 3 4]
** Basic indexing
It must be noted that the returned array is not a copy of the original, but
points *to the same values in memory* as does the original array. In the next
example, the 1-D array at the first position (0) is returned.

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(v[0])
#+end_src

#+RESULTS:
: [0 1 2 3 4]

So using a single index on the returned array, results in a single element being
returned. That is:

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(v[0][2])
#+end_src

#+RESULTS:
: 2

** Basic indexing
Note that =v[0, 2] = v[0][2]= though the second case is more inefficient a new
temporary array is created after the first index that is subsequently indexed
by 2.
** Slicing
It is possible to slice and stride arrays to extract arrays of the same number
of dimensions, but of different sizes than the original. The slicing and
striding works exactly the same way it does for lists and tuples except that
they can be applied to multiple dimensions as well. 

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.arange(10)
print(x[2:5])
print(x[:-7])
print(x[1:7:2])
#+end_src

#+RESULTS:
: 
: [2 3 4]
: [0 1 2]
: [1 3 5]

** Views
Note that slices of arrays do not copy the internal array data but also produce
new *views* of the original data.

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.arange(5)
y = x[::2]
print(x)
print(y)
y[0] = 3
print(x)
print(y)
#+end_src

#+RESULTS:
: 
: >>> [0 1 2 3 4]
: [0 2 4]
: >>> [3 1 2 3 4]
: [3 2 4]

Making changes to the view changes the underlying array!
** Views
[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.view.html][np.ndarray.view]]

New view of array with the same data and is used two different ways:
1. =a.view(some_dtype)= or =a.view(dtype=some_dtype)= constructs a view of the
   array's memory with a different data-type. This can cause a reinterpretation
   of the bytes of memory.
2. =a.view(ndarray_subclass)= or =a.view(type=ndarray_subclass)= just returns an
   instance of ndarray_subclass that looks at the same array (same shape, dtype,
   etc.) This does not cause a reinterpretation of the memory.
** Advanced indexing
It is possible to index arrays with other arrays for the purposes of selecting
lists of values out of arrays into new arrays. There are two different ways of
accomplishing this. 
- One uses one or more arrays of index values. 
- The other involves giving a boolean array of the proper shape to indicate
  the values to be selected. 
Index arrays are a very powerful tool that allow one to avoid looping
over individual elements in arrays and thus greatly improve performance.
** Index arrays
The use of index arrays ranges from simple, straightforward cases to complex,
hard-to-understand cases. For all cases of index arrays, what is returned is a
*copy* of the original data, not a view as one gets for slices.
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.arange(10, 1, -1)
y = x[np.arange(0, 8, 2)]
print(x)
print(y)
y[0] = 55
print(x)
print(y)
#+end_src

#+RESULTS:
: 
: >>> [10  9  8  7  6  5  4  3  2]
: [10  8  6  4]
: >>> [10  9  8  7  6  5  4  3  2]
: [55  8  6  4]

** Boolean index arrays
Boolean arrays used as indices are treated in a different manner entirely than
index arrays. Boolean arrays must be of the same shape as the initial dimensions
of the array being indexed.
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
y = np.arange(10)
b = y > 5
print(b, y[b])
#+end_src

#+RESULTS:
: 
: >>> (array([False, False, False, False, False, False,  True,  True,  True,  True], dtype=bool), array([6, 7, 8, 9]))

** Combining index arrays with slices
Index arrays may be combined with slices. For example:
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
y = np.arange(64).reshape(8, 8)
print(y[np.array([0,2,4]),1:3])
#+end_src

#+RESULTS:
: 
: [[ 1  2]
:  [17 18]
:  [33 34]]

Likewise, slicing can be combined with broadcasted boolean indices:
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
b = y < 10
print(y[b[:, 1], 1:3])
#+end_src

#+RESULTS:
: 
: [[ 1  2]
:  [ 9 10]]

** Structural indexing tools
To facilitate easy matching of array shapes with expressions and in assignments,
the =np.newaxis= object can be used within array indices to add new dimensions
with a size of 1. For example:
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
y = np.ones((3, 3))
print(y.shape)
print(y[:,np.newaxis,:].shape)
#+end_src

#+RESULTS:
: 
: (3, 3)
: (3, 1, 3)

* Broadcasting                                                     :noexport:
The term broadcasting describes how Numpy treats arrays with different shapes
during arithmetic operations. 

Broadcasting provides a means of vectorizing array operations so that looping
occurs in C instead of Python. It does this without making needless copies of
data and usually leads to efficient algorithm implementations. There are,
however, cases where broadcasting is a bad idea because it leads to inefficient
use of memory that slows computation.
** Broadcasting
Numpy operations are usually done on pairs of arrays on an element-by-element
basis. In the simplest case, the two arrays must have exactly the same shape, as
in the following example:

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
a = np.array([1.0, 2.0, 3.0])
b = np.array([2.0, 2.0, 2.0])
print(a * b)
print(a * 2.0)
#+end_src

#+RESULTS:
: 
: >>> [ 2.  4.  6.]
: [ 2.  4.  6.]

** General Broadcasting Rules

- When operating on two arrays, numpy compares their shapes element-wise. It
  starts with the trailing dimensions, and works its way forward. Two dimensions
  are compatible when
  - they are equal, 
  - or one of them is 1 
- If these conditions are not met, a =ValueError: frames are not aligned
  exception= is thrown, indicating that the arrays have incompatible shapes. The
  size of the resulting array is the maximum size along each dimension of the
  input arrays
** Broadcasting example
In the following example, both the A and B arrays have axes with length one that
are expanded to a larger size during the broadcast operation:

A      (4d array):  8 x 1 x 6 x 1
B      (3d array):      7 x 1 x 5
Result (4d array):  8 x 7 x 6 x 5

[[http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html][More examples]]
* Linear algebra
Vectorizing code is the key to writing efficient numerical calculation with
Python/Numpy. That means that as much as possible of a program should be
formulated in terms of matrix and vector operations, like matrix-matrix
multiplication.
** Scalar-array operations
We can use the usual arithmetic operators to multiply, add, subtract, and divide
arrays with scalar numbers.
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
v = np.arange(5)
print(v * 2, v + 3, v / 2., v - 5)
#+end_src

#+RESULTS:
: 
: (array([0, 2, 4, 6, 8]), array([3, 4, 5, 6, 7]), array([ 0. ,  0.5,  1. ,  1.5,  2. ]), array([-5, -4, -3, -2, -1]))

** Element-wise array-array operations
When we add, subtract, multiply and divide arrays with each other, the default
behaviour is element-wise operations:
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
m = np.arange(9).reshape(3, 3)
v = np.arange(3)
print(m * m)
print(m ** 2)
print(m * v)
#+end_src

#+RESULTS:
#+begin_example

>>> [[ 0  1  4]
 [ 9 16 25]
 [36 49 64]]
[[ 0  1  4]
 [ 9 16 25]
 [36 49 64]]
[[ 0  1  4]
 [ 0  4 10]
 [ 0  7 16]]
#+end_example

** Matrix algebra
We can either use the [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html][np.dot]] function, which applies a matrix-matrix,
matrix-vector, or inner vector multiplication to its two arguments:
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(np.dot(m, v))
#+end_src

#+RESULTS:
: [ 5 14 23]

For 2-D arrays it is equivalent to matrix multiplication, and for 1-D arrays to
inner product of vectors.
** Matrix algebra
Alternatively, we can cast the array objects to the type [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.html][np.matrix]]. This changes
the behavior of the standard arithmetic operators +, -, * to use matrix algebra.
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
M = np.matrix(m)
vec = np.matrix(v).T # make it a column vector
print(M * vec)
#+end_src

#+RESULTS:
: 
: >>> [[ 5]
:  [14]
:  [23]]

** Matrix algebra
More examples
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# inner product
print(np.dot(v, v))
print(vec.T * vec)
#+end_src

#+RESULTS:
: 
: 5
: [[5]]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# with matrix objects, standard matrix algebra applies
print(vec + M * vec)
#+end_src

#+RESULTS:
: 
: [[ 5]
:  [15]
:  [25]]

** Matrix computations
Inverse: [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.inv.html][np.linalg.inv]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
M = np.matrix([[4, 2, 9], [11, 2, 3], [9, 3, 1]])
print(np.linalg.inv(M))
#+end_src

#+RESULTS:
: 
: [[-0.05035971  0.17985612 -0.08633094]
:  [ 0.11510791 -0.55395683  0.62589928]
:  [ 0.10791367  0.04316547 -0.10071942]]

Determinant:[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.det.html][ np.linalg.det]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(np.linalg.det(M))
#+end_src

#+RESULTS:
: 139.0

* Data processing
Often it is useful to store datasets in Numpy arrays. Numpy provides a number of
functions to calculate statistics of datasets in arrays.
- [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.mean.html][np.mean]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.std.html][np.std]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html][np.var]]
- [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.amin.html][np.amin]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.amax.html][np.amax]]
- [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html][np.sum]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.prod.html][np.prod]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.cumsum.html][np.cumsum]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.cumprod.html][np.cumprod]]
** Some examples
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.arange(10)
print(np.sum(x))
#+end_src

#+RESULTS:
: 
: 45

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(np.mean(x))
#+end_src

#+RESULTS:
: 4.5

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(np.var(x))
#+end_src

#+RESULTS:
: 8.25

* Reshaping, resizing and stacking arrays
The shape of an Numpy array can be modified without copying the underlaying
data, which makes it a fast operation even for large arrays.
** Reshaping
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.arange(24)
print(x)
#+end_src

#+RESULTS:
: 
: [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
v = np.reshape(x, (4, 6))
print(v)
#+end_src

#+RESULTS:
: 
: [[ 0  1  2  3  4  5]
:  [ 6  7  8  9 10 11]
:  [12 13 14 15 16 17]
:  [18 19 20 21 22 23]]

** Resizing
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
v = np.array([[0, 1], [2, 3]])
x = np.resize(v, (1,4))
print(x)
#+end_src

#+RESULTS:
: 
: >>> [[0 1 2 3]]

** Repeating
Using function [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.repeat.html][np.repeat]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html][np.tile]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.vstack.html][np.vstack]], [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.hstack.html][np.hstack]], and [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html][np.concatenate]] we
can create larger vectors and matrices from smaller ones:
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
v = np.array([[1, 2], [3, 4]])
# repeat each element 3 times
print(np.repeat(v, 3))
#+end_src

#+RESULTS:
: 
: ... [1 1 1 2 2 2 3 3 3 4 4 4]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
# tile the matrix 3 times 
print(np.tile(v, 3))
#+end_src

#+RESULTS:
: 
: [[1 2 1 2 1 2]
:  [3 4 3 4 3 4]]

** Stacking
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
v = np.array([[0, 1], [2, 3]])
w = np.array([[5, 6]])
print(np.concatenate((v, w), axis=0))
#+end_src

#+RESULTS:
: 
: >>> [[0 1]
:  [2 3]
:  [5 6]]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(np.concatenate((v, w.T), axis=1))
#+end_src

#+RESULTS:
: [[0 1 5]
:  [2 3 6]]

** Stacking
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
v = np.array([[0, 1], [2, 3]])
w = np.array([[5, 6]])
x = np.vstack((v, w))
print(x)
#+end_src

#+RESULTS:
: 
: >>> >>> [[0 1]
:  [2 3]
:  [5 6]]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.hstack((v, w.T))
print(x)
#+end_src

#+RESULTS:
: 
: [[0 1 5]
:  [2 3 6]]

* Copy and "deep copy"
To achieve high performance, assignments in Python usually do not copy the
underlaying objects. This is important for example when objects are passed
between functions, to avoid an excessive amount of memory copying when it is not
necessary (technical term: pass by reference).
** Without copy
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
A = np.array([[1, 2], [3, 4]])
# now B is referring to the same array data as A 
B = A 
# changing B affects A
B[0, 0] = 10
print(A)
#+end_src

#+RESULTS:
: 
: >>> [[10  2]
:  [ 3  4]]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(B)
#+end_src

#+RESULTS:
: [[10  2]
:  [ 3  4]]
** Copy
If we want to avoid this behavior, so that when we get a new completely
independent object B copied from A, then we need to do a so-called "deep copy"
using the function copy:
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
A = np.array([[1, 2], [3, 4]])
B = A.copy()
# now, if we modify B, A is not affected
B[0, 0] = -5
print(A)
#+end_src

#+RESULTS:
: 
: >>> [[1 2]
:  [3 4]]

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(B)
#+end_src

#+RESULTS:
: [[-5  2]
:  [ 3  4]]
* Iterating over array elements
Generally, we want to avoid iterating over the elements of arrays whenever we
can (at all costs). The reason is that in a interpreted language like Python (or
MATLAB), iterations are really slow compared to vectorized operations.

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
v = np.array([1,2,3,4])
for element in v:
    print(element)
#+end_src
* Some common Numpy functions
** =np.where=
The position index can be found using the [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html][np.where]] function
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
x = np.arange(10) + 20
i = np.where((x >= 20) & (x < 25))
print(i)
#+end_src

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
print(x < 5)
#+end_src
** =np.choose=
Constructs an array by picking elements form several arrays using
[[http://docs.scipy.org/doc/numpy/reference/generated/numpy.choose.html][np.choose]]
#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
which = [1, 0, 1, 0]
choices = [[-2, -2, -2, -2], [5, 5, 5, 5]]
x = np.choose(which, choices)
print(x)
#+end_src
* Further Numpy topics
- [[http://docs.scipy.org/doc/numpy/reference/maskedarray.html][Masked arrays]]
- [[http://docs.scipy.org/doc/numpy/user/basics.io.html][Numpy IO]] (will be covered in another session)
- [[http://docs.scipy.org/doc/numpy/reference/arrays.datetime.html][Datetime and timedeltas]]
- [[http://docs.scipy.org/doc/numpy/reference/routines.polynomials.html][Numpy polynomials functions]]
- [[http://docs.scipy.org/doc/numpy/reference/routines.sort.html][Sorting, searching, counting]]
- [[http://docs.scipy.org/doc/numpy/reference/routines.logic.html][Logic functions]]
- [[http://docs.scipy.org/doc/numpy/reference/routines.statistics.html][More on statistics]]
- [[http://docs.scipy.org/doc/numpy/user/basics.rec.html][Structured arrays]] (aka "Record arrays")
- [[http://docs.scipy.org/doc/numpy/user/basics.byteswapping.html][Byte-swapping]]
- [[http://docs.scipy.org/doc/numpy/user/basics.subclassing.html][Subclassing ndarray]]
- and many [[http://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html][more]] ...
* Scipy 
[[http://docs.scipy.org/doc/][Scipy]] (Scientific Computing Tools for Python) is a Python-based ecosystem of
open-source software for mathematics, science, and engineering. In particular,
these are some of the core packages:
- Python (2.x >= 2.6 or 3.x >= 3.2)
- NumPy (>= 1.6)
- Scipy library (>= 0.10)
- Matplotlib (>= 1.1)
- dateutil
- pytz
** Scipy library
The [[http://docs.scipy.org/doc/][Scipy library]] is one of the core packages that make up the Scipy stack. It
provides many [[http://docs.scipy.org/doc/scipy/reference/][user-friendly and efficient numerical routines]] such as routines
for numerical integration and optimization.
** Example I - Interpolation (scipy.interpolate)
There are several general [[http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html][interpolation facilities]] available in Scipy, for data
in 1, 2, and higher dimension

#+begin_src python :results output :exports both :tangle lecture5.py :session *python*
from scipy.interpolate import interp1d
x = np.linspace(0, 10, 10)
y = np.cos(-x**2 / 8.0)
f = interp1d(x, y, kind='cubic')
print(y)
print(f)
#+end_src
