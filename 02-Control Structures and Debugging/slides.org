#+OPTIONS: reveal_center:t reveal_control:t reveal_height:-1
#+OPTIONS: reveal_history:nil reveal_keyboard:t reveal_mathjax:nil
#+OPTIONS: reveal_overview:t reveal_progress:t
#+OPTIONS: reveal_rolling_links:nil reveal_slide_number:t
#+OPTIONS: reveal_title_slide:t reveal_width:-1
#+options: toc:nil
#+REVEAL_MARGIN: -1
#+REVEAL_MIN_SCALE: -1
#+REVEAL_MAX_SCALE: -1
#+REVEAL_ROOT: ../reveal.js
#+REVEAL_TRANS: default
#+REVEAL_SPEED: default
#+REVEAL_THEME: black
#+REVEAL_EXTRA_CSS: ../code_formatting.css
#+REVEAL_EXTRA_JS: 
#+REVEAL_HLEVEL: 1
#+REVEAL_TITLE_SLIDE_TEMPLATE: <h1>%t</h1> <h2>%a</h2> <h2>%e</h2> <h2>%d</h2>
#+REVEAL_TITLE_SLIDE_BACKGROUND:
#+REVEAL_TITLE_SLIDE_BACKGROUND_SIZE:
#+REVEAL_TITLE_SLIDE_BACKGROUND_REPEAT:
#+REVEAL_TITLE_SLIDE_BACKGROUND_TRANSITION:
#+REVEAL_MATHJAX_URL: http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
#+REVEAL_PREAMBLE:
#+REVEAL_HEAD_PREAMBLE:
#+REVEAL_POSTAMBLE:
#+REVEAL_MULTIPLEX_ID:
#+REVEAL_MULTIPLEX_SECRET:
#+REVEAL_MULTIPLEX_URL:
#+REVEAL_MULTIPLEX_SOCKETIO_URL:
#+REVEAL_PLUGINS:

#+AUTHOR: Christoph Paulik
#+email: 
#+Title: Control Structures and Debugging

* Debugging
We will use Pyscripter here but should be very similar in most IDE's.

#+begin_src bash
cd WinPython-32bit-2.7.6.2_incl_OPALS\PyScripter-v2.5.3\PyScripter
open portable Pyscripter by starting "Start PyScripter.bat"
File->Open->lecture2.py
#+end_src

** Debugging Actions
- Breakpoint :: clicking left of line in most IDE's

#+CAPTION: Main Debugging Buttons in PyScripter
#+ATTR_LaTeX: scale=0.75
#+LABEL: fig:debugging-buttons
[[./debugging_buttons.png]]

** Interacting with the Debugger
- Python Interpreter :: write code you want to test
- Hover over variable :: shows its value 
- Variables :: list of all defined variables
- Watches :: Watch variables

** What if we do not have a GUI
#+begin_src python :results output pp :exports both
import pdb # imports the python debugger
pdb.set_trace() # sets a breakpoint
# does also work with ipython
# import ipdb
# ipdb.set_trace()
#+end_src
** 
#+begin_src python :results output pp :exports both :tangle lecture2.py
# Debugging
var1 = "test"
var2 = [1, 2, 3, 4]
var3 = {"key1": 1, "key2": 2}
print(var1, var2, var3) # set a breakpoint here, click on blue dot left of this line
var1 = "modified"
var3["key5"] = "a new value"
#+end_src
* String Formatting

#+begin_src python :results output pp :exports both :tangle lecture2.py
# String Formatting
# handy for any kind of logging, etc.
# mark replacement fields with curly braces
arg = 'world'
res = "hello {}".format(arg)
print(res)
#+end_src

#+begin_src python :results output pp :exports both :tangle lecture2.py
res = "{} and {}".format("a pear", "a tree")
print(res)
#+end_src

** 
#+begin_src python :results output pp :exports both :tangle lecture2.py
# refer to arguments by index; possibly re-use them
res = "{0} and {1}, {1} and {0}".format("a pear", "a tree")
print(res)

# refer to arguments by name; possibly re-use them
res = "{good} is better than {bad}".format(good="some", bad="nothing")
print(res)
#+end_src

** 
#+begin_src python :results output pp :exports both :tangle lecture2.py
# practically anything can be an argument to format(.)
value = 3.429188
res = "value is: {}".format(value)
print(res)

# custom formatting using format specifiers:
# format specifiers follow a colon inside the curly braces
# format as fixed point, with 3 digits after comma
res = "value is: {:.3f}".format(value)
print(res)
#+end_src

** 
#+begin_src python :results output pp :exports both :tangle lecture2.py
# format left-aligned, centered, and right-aligned 
# with the given minimum width,
# and a trailing line-break
# prepare the template-string
tpl = "{:<15} {:^5} {:>10}\n"
# provide empty string to match all replacement fields
res = tpl.format("Carl Friedrich", "", "Gauss")
# re-use the template-string
res += tpl.format("Alexander", "von",  "Humboldt")
res += tpl.format("Gerhard", "", "Mercator")
print(res)
#+end_src

** 
#+begin_src python :results output pp :exports both :tangle lecture2.py
# multi-line strings can be formatted just as well.
res = """# This might be a {}-file-header,
# created by {}
# on {}""".format("text", "me", "2014-02-18")
print(res)
#+end_src

Complete Format Specification Mini-Language:
http://docs.python.org/2/library/string.html#formatspec

* Loops and Conditions
#+begin_src python :results output pp :exports both :tangle lecture2.py
i = 0
data = [2, 4.5]
while i < len(data):
    print(data[i])
    i += 1
#+end_src

#+RESULTS:
: 2
: 4.5


** 
Python does loops a little different.
#+begin_src python :results output pp :exports both :tangle lecture2.py
data = [ 1.73, 2.4122, 80, -4 ]

# iterate over elements, using keyword 'in'
for elem in data:
    print(elem)
#+end_src

** iterate over multiple lists
#+begin_src python :results output pp :exports both :tangle lecture2.py
data = [ 1.73, 2.4122, 80, -4 ]
datanames = ["number 1", "number 2", "number 3", "number 4"]
for number, name in zip(data, datanames):
    print(name, number)
#+end_src

** iterate over dictionaries
#+begin_src python :results output pp :exports both :tangle lecture2.py
d = {"key1": 1, "key2": 2, "key3": 3}
for key in d:
    print(key)
#+end_src

#+RESULTS:
: ('key3', 3)
: ('key2', 2)
: ('key1', 1)

#+begin_src python :results output pp :exports both :tangle lecture2.py
d = {"key1": 1, "key2": 2, "key3": 3}
for key, item in d.iteritems():
    print(key, item)
#+end_src

#+RESULTS:
: ('key3', 3)
: ('key2', 2)
: ('key1', 1)

** sometimes you need an indices
range and xrange can be addressed with (start, stop, step)
#+begin_src python :results output pp :exports both
  print("range")
  for i in range(1, 10, 2):
      print(i)
  print("xrange")
  for i in xrange(5): # only python 2
      print(i)
#+end_src

** sometimes enumerate is also handy
#+begin_src python :results output pp :exports both
l = ["a", "b", "c", "d"]
for i, item in enumerate(l):
    print(i, item)
#+end_src

** if/else blocks
#+begin_src python :results output pp :exports both :tangle lecture2.py
dataset1 = [ 1.73, 2.4122, 80, -4 ]
# if/else blocks
for d in dataset1:
    if d > 3:
        res = ">3"
    else:
        res = "<=3"
    print(res)
#+end_src

** Mini Exercise
#+begin_src python :results output pp :exports both :tangle lecture2.py
####################################################################
# Mini Exercise 

# Try to format and print only the positive numbers in 'dataset1',
# with 1 number on each line,
# and with 2 digits after the comma

####################################################################
#+end_src

* Functions
Function is a way to package code so that it is reusable.
#+begin_src python :results output pp :session func1 :exports both :tangle lecture2.py
  def classify(dataset, threshold):
      """
      classifies dataset into small and large class using the threshold

      Parameters
      ----------
      dataset: list
          list to classify
      threshold: float
          threshold to use for classification

      Returns
      -------
      results: list
          containing True or False
      """
      results = []  # create an empty list
      for data in dataset:
          results.append(data > threshold)
      return results
#+end_src

** 
#+begin_src python :results output  pp :session func1 :exports both :tangle lecture2.py
dataset1 = [1.73, 80, 2.4122, -4]
res = classify(dataset1, 2)
print(res)
print(classify(dataset1, 1))
#+end_src

** Documentation
There are several ways to document code in Python. 

Scientists often use the [[https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt][numpy Documentation style.]]

There is also [[https://www.python.org/dev/peps/pep-0257/][PEP 257 Python Docstring Standard]]

#+ATTR_REVEAL: :frag grow highlight-red
Be Consistent

** 
Documentation is useful for autocompletion in IDE

Generation of HTML or PDF Documentation using [[http://sphinx-doc.org/][Sphinx]].

** Functions with keyword arguments

#+begin_src python :results output pp :session func1 :exports both :tangle lecture2.py
  def classifydefault(dataset, threshold=2.5):
      """
      classifies dataset into small and large class using the threshold

      Parameters
      ----------
      dataset: list
          list to classify
      threshold: float, optional
          threshold to use for classification

      Returns
      -------
      results: list
          containing True or False
      """
      results = []  # create an empty list
      for data in dataset:
          results.append(data > threshold)
      return results
#+end_src

** 
#+begin_src python :results output  pp :session func1 :exports both :tangle lecture2.py
dataset2 = [1.73, 80, 2.4122, -4, 2.6]
print(classifydefault(dataset2))
#+end_src

** Namespaces
Functions/Classes and Packages/Modules define their own local namespace.
#+begin_src python :results output pp :exports both :tangle lecture2.py
variable = "I am Global"
def func():
    variable = "I am Local"
    print(variable)

print(variable)
func()
#+end_src

#+RESULTS:
: I am Global
: I am Local

** Functions and mutable types
Careful when changing a list in a function
#+begin_src python :results output pp :exports both :tangle lecture2.py
l = [1, 2, 3]
def func(ls):
    ls.append(4)

print(l)
func(l)
print(l)
#+end_src

#+RESULTS:
: [1, 2, 3]
: [1, 2, 3, 4]

** Mini Exercise
#+begin_src python :results output pp :exports both :tangle lecture2.py
####################################################################
# Mini Exercise 

# Write a function that classifies strings by length
# inputs should be a list of strings, and a threshold 
# specifying the number of characters
# The output should be a list containing the strings "shorter" or "longer"
# lets ignore strings of length = threshold for now
print(len("test")) # hint
# list of random strings
test_strings = ["faucal" ,"fiddling" ,"instil" ,"blake" ,"profanely" ,
                "bootblack" ,"decongest" ,"interest" ,"arrowy" ,"eponymic"]
####################################################################
#+end_src


